# Haskell Theory Exploration #

## A Wrapper Around QuickSpec ##

This repository provides commands for performing "theory exploration", mostly in
the Haskell programming language. Theory exploration describes the task of
taking in some function definitions and outputting conjectures about those
functions. For example, given an `append` function for lists, we might get the
following conjectures:

    append x nil = x
    append nil x = x
    append x (append y z) = append (append x y) z

In this case, we've found that `append` and `nil` form a monoid for lists :)

Currently, we're limited to finding equations. We rely on the excellent
QuickSpec library to do most of the work, but we also use and provide many
complementary tools. We use Nix to tame the menagerie of languages and systems
'under the hood'.

## Overview ##

This implementation of theory exploration can be thought of as "dynamic
analysis", since we discover properties of the given code by running it over and
over in many combinations. The Haskell programming language is well suited to
this, since its "purity" prevents functions relying on any ambient 'context'
(everything a Haskell function needs should be taken in as an argument), and the
type system tells us which functions we can combine together, and what arguments
they should be given. The QuickSpec system uses this knowledge, along with the
type-directed data generators from QuickCheck, to find combinations of the given
functions which seem to behave the same way on many inputs. Those which do are
conjectured to be equivalent.

Whilst QuickSpec is very useful, it has a few weaknesses which we seek to
address:

 - We provide a wrapper around the QuickSpec library, allowing it to be run as a
   standalone program.
 - We provide a tool to extract all functions from a Haskell package, and
   generate a suitable signature for QuickSpec, so the user doesn't have to.
 - To generate our signatures, we automatically pick suitable names, types,
   arities, data generators, comparison functions and free variables for all
   relevant functions.
 - We call out to Nix to ensure that all necessary packages (QuickSpec and
   whatever is to be explored) are available.
 - We replace QuickSpec's custom pretty-printer with a JSON format which is more
   amenable to subsequent processing.
 - We split apart QuickSpec's exploration phase from its 'filter out redundant
   conjectures' phase, in case users want to explore without filtering, or want
   to filter some separate data.
 - We allow functions to be split into separate "buckets" for concurrent
   exploration, as well as a few "bucketing" algorithms to select how this
   splitting up should be performed.

## Design Goals ##

The design of this codebase is influenced by the following considerations:

*Exploring arbitrary (Haskell) code*

To be as useful as possible, we want to accept as much "normal" Haskell code as
we can, rather than placing too many requirements on users. Since the vast
majority of Haskell code only works with GHC, due to language extensions,
dependencies, etc. we're pretty much forced to use it.

Likewise, most code won't build without taking specific instructions into
account, like ensuring dependencies are available, preprocessors are executed,
commandline flags are provided, etc. This forces us to use a build system, so
we've opted for Cabal since it's been around for long enough to "just work" in
most situations, especially with Nix.

We're also forced to use an "eval" mechanism, since we need to run code supplied
by the user at runtime, but GHC is an ahead-of-time compiler. We've opted for
`nix-eval`, which spawns `runghc` in a subprocess and pipes in the given code.
As the name suggests, `nix-eval` runs this subprocess in an environment provided
by Nix, which lets us fetch, build and install any packages needed by the user's
code.

*Measuring performance*

We want a way to reliably measure and compare different exploration algorithms
and approaches. This requires the code to be:

 - Highly automated, so many repetitions can be executed, against many different
   inputs, with as little human intervention as possible.
 - Modular, so that algorithms can be swapped out and separate components can be
   run independently: in particular so we can time the exploration without
   including things like function extraction.
 - Deterministic and reproducible, as far as possible, so experiments can be
   replicated and results can be compared.
 - Fast at running a "happy path", allowing us to perform any expensive setup
   (like compiling dependencies and creating environments) beforehand, so they
   don't contribute to the measured runtime. In particular, we need to prevent
   `nix-eval` from having to compile dependencies during a run.

## Commands ##

Here, we use "Haskell package" to mean a directory containing a Haskell project,
with a `.cabal` file, etc.

The Nix package defined in `default.nix` provides the following commands:

 - `quickspec` takes the path to a Haskell package as an argument, explores the
   code it finds inside, and writes the conjectures it discovers to stdout.
 - `renderEqs` reads conjectures from stdin and pretty-prints a more
   human-friendly syntax to stdout.
 - `reduce-equations` reads conjectures from stdin and writes to stdout only
   those which aren't "redundant" (i.e. it removes anything which is just a
   special case of some other conjecture).
 - `haskellPkgToAsts` takes the path to a Haskell package as an argument and
   outputs JSON describing the functions defined inside.
 - `quickspecAsts` will explore the equations described by JSON given on stdin,
   in the same format outputted by `haskellPkgToAsts`. The Haskell package must
   also be given as an argument, so GHC knows where to find it.
 - `concurrentQuickspec` takes an *array* of JSON on stdin, and launches a
   QuickSpec process for each, gathering up the conjectures from all of them.

The intermediate JSON data is useful if we want to remove particular functions
from being explored, or if we want to explore functions from multiple packages.
Tools like `jq` are handy for manipulating this JSON.

Note that during AST extraction, we try to determine whether or not a function
is usable by QuickSpec. The result is stored in the `quickspecable` field, and
if this is `false` you may have trouble sending it into an exploration command
like `quickspec` or `concurrentQuickspec`. You can filter out such entries using
tools like `jq`, e.g.

    jq 'map(select(.quickspecable))' < ./myAstsFile | quickspecAsts

## Examples ##

We can start a shell with this package in scope as follows:

    $ nix-shell --show-trace -p 'import ./. {}'

This should drop us to a "nix shell" with the above commands in our `PATH`:

    [nix-shell]$ command -v quickspecAsts
    /nix/store/...-haskell-theory-exploration/bin/quickspecAsts

We need some code to explore; you'll probably be using your own projects, but
here we'll fetch a package from Hackage:

    [nix-shell]$ cabal get dlist
    Warning: The package list for 'hackage.haskell.org' is 310 days old.
    Run 'cabal update' to get the latest list of available packages.
    Downloading dlist-0.8.0.2...
    Unpacking to dlist-0.8.0.2/

First let's try exploring it, by passing the unpacked directory to `quickspec`:

    [nix-shell]$ quickspec dlist-0.8.0.2 | tee dlist.eqs
    these derivations will be built:
      /nix/store/jpzhn0ww9c3dvh62hmpcrib6xkdxbndd-ghc-7.10.3.drv
    building path(s) ‘/nix/store/x6nfs4mh02h58a3g1z1a80c4pw5dqgmz-ghc-7.10.3’
    <the usual messages from nix, haddock, and cabal>

    Checking module availability
    Found modules
    Building type-extraction command
    Extracting types
    Building scope-checking command
    Checking scope
    Outputting JSON
    Finished output
    Set DEBUG=1 if you want to see gory GHCi output.

    This stage is tricky. Set DEBUG=1 to see the debug info.
    Getting ASTs
    Getting types
    Getting scope
    Tagging
    Tagged
    <more messages from nix, haddock and cabal>
    building path(s) ‘/nix/store/8cwvwrw10i2yfgq7xy820wqrhy33vkq5-quickspec-runner’
    [
      {
        "relation": "~=",
        ...
      },
      ...
    ]

This can take a while, and you might want to keep an eye on GHC's memory usage.
The messages in the middle are from our AST extraction system as it finds
which functions are defined in `dlist` and their types, arities, etc.

The result is a bunch of conjectured equations involving the package's
functions. By default these are in a machine-readable JSON format, so they can
be piped into other tools. Since we want to read them, we'll pipe them into
`renderEqs`:

    [nix-shell]$ renderEqs < dlist.eqs
    ((foldr iii9) i0) empty ~= i0
    (cons i0) empty ~= singleton i0
    (map ii3) empty ~= empty
    (snoc empty) i0 ~= singleton i0
    (apply empty) i15 ~= i15
    head empty ~= undefined
    tail empty ~= undefined
    (append empty) empty ~= empty
    (snoc ((replicate i12) i0)) i0 ~= (cons i0) ((replicate i12) i0)
    (snoc (singleton i0)) i1 ~= (cons i0) (singleton i1)
    head (singleton i0) ~= i0
    tail (singleton i0) ~= empty
    toList (fromList i15) ~= i15
    (append ((unfoldr imii6) i0)) (singleton i1) ~= (snoc ((unfoldr imii6) i0)) i1
    (append ((replicate i12) i0)) (singleton i1) ~= (snoc ((replicate i12) i0)) i1
    (append ((replicate i13) i0)) ((replicate i12) i0) ~= (append ((replicate i12) i0)) ((replicate i13) i0)
    (append (singleton i0)) ((unfoldr imii6) i1) ~= (cons i0) ((unfoldr imii6) i1)
    (append (singleton i0)) ((replicate i12) i1) ~= (cons i0) ((replicate i12) i1)
    (append empty) ((unfoldr imii6) i0) ~= (unfoldr imii6) i0
    (append empty) ((replicate i12) i0) ~= (replicate i12) i0
    (append ((unfoldr imii6) i0)) empty ~= (unfoldr imii6) i0
    (append ((replicate i12) i0)) empty ~= (replicate i12) i0
    (append (singleton i0)) (singleton i1) ~= (cons i0) (singleton i1)
    (append (singleton i0)) (fromList i15) ~= (cons i0) (fromList i15)
    (append (fromList i15)) (singleton i0) ~= (snoc (fromList i15)) i0
    (append empty) (singleton i0) ~= singleton i0
    (append empty) (fromList i15) ~= fromList i15
    (append (singleton i0)) empty ~= singleton i0
    (append (fromList i15)) empty ~= fromList i15
    fromList (toList empty) ~= empty
    (apply ((unfoldr imii6) i0)) (toList empty) ~= toList ((unfoldr imii6) i0)
    (apply ((replicate i12) i0)) (toList empty) ~= toList ((replicate i12) i0)
    (apply (singleton i0)) (toList empty) ~= toList (singleton i0)
    (apply (fromList i15)) (toList empty) ~= i15

We use the symbol `~=` to indicate that these are not definitions or proven
theorems, they're just conjectures based on many empirical tests. The numbered
terms like `ii3` are free variables: the letters come from the type and the
numbers distinguish between different variables of the same type. Here we've
found that `toList` is the inverse of `fromList`, that `head` is the inverse of
`singleton`, etc.

Notice that there are several equations of the form `(append empty) x = x`, but
that more general statement itself wasn't conjectured. The reason is that `x`
would be a variable of type `DList a` (in fact `DList Integer`, since we
monomorphise), but the `dlist` package doesn't expose a `DList a` instance of
QuickCheck's `Arbitrary` type class. Without this, we don't know how to test
equations involving such variables, so we cannot include such variables in our
expressions, and hence the general equation wasn't found.

If we want more control over what gets explored, we can use `haskellPkgToAsts`
to dump out a package's information as JSON, without exploring it immediately:

    [nix-shell]$ haskellPkgToAsts dlist-0.8.0.2 | tee dlist.asts
    <nix, haddock and cabal output>

    Checking module availability
    Found modules
    Building type-extraction command
    Extracting types
    Building scope-checking command
    Checking scope
    Outputting JSON
    Finished output
    Set DEBUG=1 if you want to see gory GHCi output.

    This stage is tricky. Set DEBUG=1 to see the debug info.
    Getting ASTs
    Getting types
    Getting scope
    Tagging
    Tagged
    [{"name":"replicate","version":"0.8.0.2",...},...]

Tools like `jq` can manipulate this JSON. We can use them to mix and match
functions from different packages. For example, we can take functions from the
`LazyLength` module of the `list-extras` package, any functions from `dlist`
which have `List` in their name, and explore them together. Note that we provide
both package directories to `quickspecAsts`, so it knows where to find all of
the necessary code:

    [nix-shell]$ cabal get list-extras
    [nix-shell]$ haskellPkgToAsts list-extras-0.4.1.4 > list-extras.asts
    [nix-shell]$ jq -n --argfile le list-extras.asts \
                       --argfile dl dlist.asts       \
                       '($dl | map(select(.name   | contains("List")))) +
                        ($le | map(select(.module | contains("LazyLength"))))' |
                 quickspecAsts dlist-0.8.0.2 list-extras-0.4.1.4               |
                 renderEqs
    (lengthCompare i19) i19 ~= (lengthCompare i18) i18
    toList (fromList i18) ~= i18

In this case we didn't find any equations involving both `lengthCompare` and
`toList`/`fromList`, so there's no need to explore them together. Instead, we
could explore them in separate processes using `concurrentQuickspec`:

    [nix-shell]$ jq -n --argfile le list-extras.asts \
                       --argfile dl dlist.asts       \
                       '[($dl | map(select(.name   | contains("List"))))] +
                        [$le | map(select(.module | contains("LazyLength")))]' |
                 concurrentQuickspec dlist-0.8.0.2 list-extras-0.4.1.4         |
                 renderEqs
    (lengthCompare i19) i19 ~= (lengthCompare i18) i18
    toList (fromList i18) ~= i18

## Caveats ##

We abstract over a lot of implementation details. These abstractions are leaky,
so you may encounter problems. Here are some known difficulties and workarounds:

*Function extraction uses a GHC compiler plugin*

This means we must be able to compile your code with GHC. We do this by invoking
Cabal, with specially crafted arguments in a specially crafted environment. If
your code doesn't have an accompanying `.cabal` file we *cannot* extract
function information from it. We have no plans to support alternative build
tools at this time.

Note that it is still be possible to *explore* non-Cabal packages (e.g. with
`quickspecAsts` or `concurrentQuickspec`), but `haskellPkgToAsts` cannot be used
to extract the function information; you'll have to provide it some other way.

*Packages must be installable by Nix*

We use Nix to set up our working environments, e.g. for compiling, for querying
GHCi, for exploring, etc. If your package can't be built by Nix then *it will
not work*. Unlike the Cabal requirement, this cannot be worked around.

There are two ways to make a package work with Nix. The easiest is to have a
working `.cabal` file, in which case we will automatically run `cabal2nix` to
convert it to Nix. If this doesn't work, or you don't have a `.cabal` file, then
you can provide your own definition in a `default.nix` file instead. This should
follow the same convention as those produced by `cabal2nix`.

*Dependency hell*

We use a few Haskell packages internally. Some, like `reduce-equations`, provide
standalone commands which don't interfere with the packages being explored.
Others, like `QuickSpec` and `AstPlugin`, must be installed into the same
`ghc-pkg` database as the packages being explored, so there is potential for
dependencies to clash.

Clashes with `AstPlugin` can be worked around by using `quickspecAsts` and
providing JSON data from somewhere other than `haskellPkgToAsts`.

Clashes with packages used during exploration (e.g. `QuickSpec`) cannot be
worked around, due to the nature of the algorithm: functions from one must be
invoked by the other, so their dependencies must be compatible.

*Overrides*

We prefer to hard-code our dependency versions, to make results more
deterministic and reproducible, but if this prevents some package from building
then they can be overridden in the following ways:

 - Our package accepts overridable parameters, including `stable` which defaults
   to `true`. If set to `false`, we will check out the latest revision of each
   git repository we access, rather than the known-good revision we've
   hard-coded. For example: `nix-shell -p 'import ./. { stable = false; }'`
 - Some dependencies are looked up in the `NIX_PATH` environment variable,
   falling back to the hard-coded versions if no override is given.
 - We avoid using the `<nixpkgs>` path, since differs among systems
 - The `HASKELL_PACKAGES` environment variable can be set to a `.nix` file to
   override which Haskell package set is used by the exploration process. Note
   that this will not affect things *other* than exploration, like function
   extraction or setup code.
 - Note that we use the `nix-eval` package, but we *don't* expose its
   `NIX_EVAL_HASKELL_PKGS` override. That's because we need to use it ourselves,
   but the `HASKELL_PACKAGES` we provide acts in a similar way.

*Extraction caveats*

`haskellPkgToAsts` looks at all of the functions defined in the given package.
In particular, it *does not* extract anything which is re-exported from a
*different* package, and it does not include constuctors or type class methods.

If a package defines things in a "private" module, and exports them from an
exposed module, then the functions may get tagged as belonging to the *private*
module. When we later try to import these functions, it will fail because that
module is not exposed.

There is also an edge case if a package defines types separately to functions:
we will import the modules providing the functions, but if we try to reference
the types, e.g. to add typed variables to the signature, we will get an error
since they're not in scope.

*Polymorphism, higher kinds, Arbitrary, Ord, etc.*

QuickSpec's exploration algorithm relies on the use of free variables, and
testing by plugging many different values into these variables to see what
happens.

To do this, we need instances of QuickCheck's `Arbitrary` typeclass for each
function's inputs, so we can generate random values. We also need the outputs to
be comparable, either by having an instance of `Ord` (we could use `Eq`, but it
would require O(n^2) comparisons) or an instance of `Serialize`.

We use the latter if possible: serialising return values, hashing the resulting
string and comparins. We do this in an attempt to reduce memory usage, since
keeping many large values in memory for comparisons can be expensive, compared
to keeping many fixed-length hashes.

Another consideration is that we need code to be monomorphic: we can't generate
random inputs if we don't know which particular type to generate values of. For
example, to explore `id :: (Arbitrary a) => a -> a`, how do we choose which `a`
to use?

We solve this by 'monomorphising': replacing type variables with a particular
concrete type. Currently, we replace variables of kind `*` with `Integer` and
those of kind `* -> *` with `[]` (i.e. lists). If the variable has constraints,
and these aren't satisfied by `Integer` or `[]`, then we use Template Haskell to
look up a valid instance in the module's scope; if there are multiple
possibilities, one is chosen non-deterministically.

These instance-finding mechanisms are rather basic and could certainly be
improved, but more sophisticated approaches (e.g. logic programming) would be
better off being developed as a separate project.

It's easy to work around most of these mechanisms' failures, by simply writing
down monomorphic versions of your functions, e.g.

    myCrazyFunc :: Madness
    myCrazyFunc = ...

    myMonoFunc :: Bool -> String
    myMonoFunc = myCrazyFunc

One annoyance is that many projects use QuickCheck "internally", and hence have
`Arbitrary` instances for their types, but they don't provide these in their
library interface, so we can't use them.

*Resource usage*

We use QuickSpec version 1, which has a rather slow algorithm. In particular,
memory usage may explode when exploring some functions and not for others. To
prevent GHC eating all of your resources, it can be killed after a time limit by
setting the `MAX_SECS` env var, or memory limit by setting `MAX_KB`.

## Other Details ##

 - Tested on NixOS Linux, but other Linux systems should also work
 - The main "user facing" functionality is the package provided by `default.nix`
 - The main "researcher facing" functionality is the benchmark suite, which is
   explained in more detail by `benchmarks/README`
