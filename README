# Haskell Theory Exploration #

This repository provides commands for performing "theory exploration", mostly in
the Haskell programming language. Theory exploration describes the task of
taking in some function definitions and outputting conjectures about those
functions. For example, given an `append` function for lists, we might get the
following conjectures:

    append x nil = x
    append nil x = x
    append x (append y z) = append (append x y) z

In this case, we've found that `append` and `nil` form a monoid for lists :)

Currently, we're limited to finding equations. We rely on QuickSpec to do most
of the work, but we also use and provide many complementary tools. We use Nix to
tame the menagerie of languages and systems 'under the hood'.

## Overview ##

This implementation of theory exploration can be thought of as "dynamic
analysis", since we discover properties of the given code by running it over and
over in many combinations. The Haskell programming language is well suited to
this, since its "purity" prevents functions relying on any ambient 'context'
(everything a Haskell function needs should be taken in as an argument), and the
type system tells us which functions we can combine together, and what arguments
they should be given. The QuickSpec system uses this knowledge, along with the
type-directed data generators from QuickCheck, to find combinations of the given
functions which seem to behave the same way on many inputs. Those which do are
conjectured to be equivalent.

Whilst QuickSpec is very useful, it has a few weaknesses which we seek to
address:

 - We provide a wrapper around the QuickSpec library, allowing it to be run as a
   standalone program.
 - We provide a tool to extract all functions from a Haskell package, and
   generate a suitable signature for QuickSpec, so the user doesn't have to.
 - To generate our signatures, we automatically pick suitable names, types,
   arities, data generators, comparison functions and free variables for all
   relevant functions.
 - We call out to Nix to ensure that all necessary packages (QuickSpec and
   whatever is to be explored) are available.
 - We replace QuickSpec's custom pretty-printer with a JSON format which is more
   amenable to subsequent processing.
 - We split apart QuickSpec's exploration phase from its 'filter out redundant
   conjectures' phase, in case users want to explore without filtering, or want
   to filter some separate data.
 - We allow functions to be split into separate "buckets" for concurrent
   exploration, as well as a few "bucketing" algorithms to select how this
   splitting up should be performed.

## Design Goals ##

The design of this codebase is influenced by the following considerations:

*Exploring arbitrary (Haskell) code*

To be as useful as possible, we want to accept as much "normal" Haskell code as
we can, rather than placing too many requirements on users. Since the vast
majority of Haskell code only works with GHC, due to language extensions,
dependencies, etc. we're pretty much forced to use it.

Likewise, most code won't build without taking specific instructions into
account, like ensuring dependencies are available, preprocessors are executed,
commandline flags are provided, etc. This forces us to use a build system, so
we've opted for Cabal since it's been around for long enough to "just work" in
most situations, especially with Nix.

We're also forced to use an "eval" mechanism, since we need to run code supplied
by the user at runtime, but GHC is an ahead-of-time compiler. We've opted for
`nix-eval`, which spawns `runghc` in a subprocess and pipes in the given code.
As the name suggests, `nix-eval` runs this subprocess in an environment provided
by Nix, which lets us fetch, build and install any packages needed by the user's
code.

*Measuring performance*

We want a way to reliably measure and compare different exploration algorithms
and approaches. This requires the code to be:

 - Highly automated, so many repetitions can be executed, against many different
   inputs, with as little human intervention as possible.
 - Modular, so that algorithms can be swapped out and separate components can be
   run independently: in particular so we can time the exploration without
   including things like function extraction.
 - Deterministic and reproducible, as far as possible, so experiments can be
   replicated and results can be compared.
 - Fast at running a "happy path", allowing us to perform any expensive setup
   (like compiling dependencies and creating environments) beforehand, so they
   don't contribute to the measured runtime. In particular, we need to prevent
   `nix-eval` from having to compile dependencies during a run.

## Commands ##

Here, we use "Haskell package" to mean a directory containing a Haskell project,
with a `.cabal` file, etc.

The Nix package defined in `default.nix` provides the following commands:

 - `quickspec` takes the path to a Haskell package as an argument, explores the
   code it finds inside, and writes the conjectures it discovers to stdout.
 - `renderEqs` reads conjectures from stdin and pretty-prints a more
   human-friendly syntax to stdout.
 - `reduce-equations` reads conjectures from stdin and writes to stdout only
   those which aren't "redundant" (i.e. it removes anything which is just a
   special case of some other conjecture).
 - `haskellPkgToAsts` takes the path to a Haskell package as an argument and
   outputs JSON describing the functions defined inside.
 - `quickspecAsts` will explore the equations described by JSON given on stdin,
   in the same format outputted by `haskellPkgToAsts`. The Haskell package must
   also be given as an argument, so GHC knows where to find it.
 - `concurrentQuickspec` takes an *array* of JSON on stdin, and launches a
   QuickSpec process for each, gathering up the conjectures from all of them.

The intermediate JSON data is useful if we want to remove particular functions
from being explored, or if we want to explore functions from multiple packages.
Tools like `jq` are handy for manipulating this JSON.

Note that during AST extraction, we try to determine whether or not a function
is usable by QuickSpec. The result is stored in the `quickspecable` field, and
if this is `false` you may have trouble sending it into an exploration command
like `quickspec` or `concurrentQuickspec`. You can filter out such entries using
tools like `jq`, e.g.

    jq 'map(select(.quickspecable))' < ./myAstsFile | quickspecAsts

## Examples ##

We can start a shell with this package in scope as follows:

    $ nix-shell --show-trace -p 'import ./. {}'

This should drop us to a "nix shell" with the above commands in our `PATH`:

    [nix-shell]$ command -v quickspecAsts
    /nix/store/...-haskell-theory-exploration/bin/quickspecAsts

We need some code to explore; you'll probably be using your own projects, but
here we'll fetch a package from Hackage:

    [nix-shell]$ cabal get dlist
    Warning: The package list for 'hackage.haskell.org' is 310 days old.
    Run 'cabal update' to get the latest list of available packages.
    Downloading dlist-0.8.0.2...
    Unpacking to dlist-0.8.0.2/

First let's try exploring it, by passing the unpacked directory to `quickspec`:

    [nix-shell]$ quickspec dlist-0.8.0.2 | tee dlist.eqs
    these derivations will be built:
      /nix/store/jpzhn0ww9c3dvh62hmpcrib6xkdxbndd-ghc-7.10.3.drv
    building path(s) ‘/nix/store/x6nfs4mh02h58a3g1z1a80c4pw5dqgmz-ghc-7.10.3’
    <the usual messages from nix, haddock, and cabal>

    Checking module availability
    Found modules
    Building type-extraction command
    Extracting types
    Building scope-checking command
    Checking scope
    Outputting JSON
    Finished output
    Set DEBUG=1 if you want to see gory GHCi output.

    This stage is tricky. Set DEBUG=1 to see the debug info.
    Getting ASTs
    Getting types
    Getting scope
    Tagging
    Tagged
    <more messages from nix, haddock and cabal>
    building path(s) ‘/nix/store/8cwvwrw10i2yfgq7xy820wqrhy33vkq5-quickspec-runner’
    [
      {
        "relation": "~=",
        ...
      },
      ...
    ]

This can take a while, and you might want to keep an eye on GHC's memory usage.
The messages in the middle are from our AST extraction system as it finds
which functions are defined in `dlist` and their types, arities, etc.

The result is a bunch of conjectured equations involving the package's
functions. By default these are in a machine-readable JSON format, so they can
be piped into other tools. Since we want to read them, we'll pipe them into
`renderEqs`:

    [nix-shell]$ renderEqs < dlist.eqs
    ((foldr iii9) i0) empty ~= i0
    (cons i0) empty ~= singleton i0
    (map ii3) empty ~= empty
    (snoc empty) i0 ~= singleton i0
    (apply empty) i15 ~= i15
    head empty ~= undefined
    tail empty ~= undefined
    (append empty) empty ~= empty
    (snoc ((replicate i12) i0)) i0 ~= (cons i0) ((replicate i12) i0)
    (snoc (singleton i0)) i1 ~= (cons i0) (singleton i1)
    head (singleton i0) ~= i0
    tail (singleton i0) ~= empty
    toList (fromList i15) ~= i15
    (append ((unfoldr imii6) i0)) (singleton i1) ~= (snoc ((unfoldr imii6) i0)) i1
    (append ((replicate i12) i0)) (singleton i1) ~= (snoc ((replicate i12) i0)) i1
    (append ((replicate i13) i0)) ((replicate i12) i0) ~= (append ((replicate i12) i0)) ((replicate i13) i0)
    (append (singleton i0)) ((unfoldr imii6) i1) ~= (cons i0) ((unfoldr imii6) i1)
    (append (singleton i0)) ((replicate i12) i1) ~= (cons i0) ((replicate i12) i1)
    (append empty) ((unfoldr imii6) i0) ~= (unfoldr imii6) i0
    (append empty) ((replicate i12) i0) ~= (replicate i12) i0
    (append ((unfoldr imii6) i0)) empty ~= (unfoldr imii6) i0
    (append ((replicate i12) i0)) empty ~= (replicate i12) i0
    (append (singleton i0)) (singleton i1) ~= (cons i0) (singleton i1)
    (append (singleton i0)) (fromList i15) ~= (cons i0) (fromList i15)
    (append (fromList i15)) (singleton i0) ~= (snoc (fromList i15)) i0
    (append empty) (singleton i0) ~= singleton i0
    (append empty) (fromList i15) ~= fromList i15
    (append (singleton i0)) empty ~= singleton i0
    (append (fromList i15)) empty ~= fromList i15
    fromList (toList empty) ~= empty
    (apply ((unfoldr imii6) i0)) (toList empty) ~= toList ((unfoldr imii6) i0)
    (apply ((replicate i12) i0)) (toList empty) ~= toList ((replicate i12) i0)
    (apply (singleton i0)) (toList empty) ~= toList (singleton i0)
    (apply (fromList i15)) (toList empty) ~= i15

We use the symbol `~=` to indicate that these are not definitions or proven
theorems, they're just conjectures based on many empirical tests. The numbered
terms like `ii3` are free variables: the letters come from the type and the
numbers distinguish between different variables of the same type. Here we've
found that `toList` is the inverse of `fromList`, that `head` is the inverse of
`singleton`, etc.

Notice that there are several equations of the form `(append empty) x = x`, but
that more general statement itself wasn't conjectured. The reason is that `x`
would be a variable of type `DList a` (in fact `DList Integer`, since we
monomorphise), but the `dlist` package doesn't expose a `DList a` instance of
QuickCheck's `Arbitrary` type class. Without this, we don't know how to test
equations involving such variables, so we cannot include such variables in our
expressions, and hence the general equation wasn't found.
## Caveats ##

We abstract over a lot of implementation details. These abstractions are leaky,
so you may encounter problems. Here are some known difficulties and workarounds:

*AST extraction uses a GHC compiler plugin*

This means we must be able to compile your code with GHC. We do this by invoking
Cabal, with specially crafted arguments in a specially crafted environment. If
your code doesn't have an accompanying `.cabal` file we *cannot* extract
function information from it. We have no plans to support alternative build
tools. In particular, we do *not* support Stack, despite its popularity, for the
simple reason that after a great deal of effort, adding up to many wasted days,
spread across several attempts, with different versions, the author still hasn't
managed to get Stack to even *compile*.

Note that it is still be possible to *explore* non-Cabal packages, as long as
they're installable by Nix, but the function information (normally produced by
`haskellPkgToAsts`) must be provided by some other means.

*Packages must be installable by Nix*

We use Nix to set up our working environments, e.g. for compiling, for querying
GHCi, for exploring, etc. If your package can't be built by Nix then *it will
not work*. Unlike the Cabal requirement, this cannot be worked around.

There are two ways to make a package work with Nix. The easiest is to have a
working `.cabal` file, in which case we will automatically run `cabal2nix` to
convert it to Nix. If this doesn't work, or you don't have a `.cabal` file, then
you can provide your own definition in a `default.nix` file instead. This should
follow the same convention as those produced by `cabal2nix`.

*Dependency hell*

We use a few Haskell packages internally. Some, like `reduce-equations`, provide
standalone commands which don't interfere with the packages being explored.
Others, like `QuickSpec` and `AstPlugin`, must be installed into the same
`ghc-pkg` database as the packages being explored, so there is potential for
dependencies to clash.

Clashes with `AstPlugin` can be worked around by using `quickspecAsts` and
providing JSON data from somewhere other than `haskellPkgToAsts`.

Clashes with packages used during exploration (e.g. `QuickSpec`) cannot be
worked around, due to the nature of the algorithm: functions from one must be
invoked by the other, so their dependencies must be compatible.

*Overrides*

We prefer to hard-code our dependency versions, to make results more
deterministic and reproducible, but if this prevents some package from building
then they can be overridden in the following ways:

 - Our package accepts overridable parameters, including `stable` which defaults
   to `true`. If set to `false`, we will check out the latest revision of each
   git repository we access, rather than the known-good revision we've
   hard-coded. For example: `nix-shell -p 'import ./. { stable = false; }'`
 - Some dependencies are looked up in the `NIX_PATH` environment variable,
   falling back to the hard-coded versions if no override is given.
 - We avoid using the `<nixpkgs>` path, since differs among systems
 - The `HASKELL_PACKAGES` environment variable can be set to a `.nix` file to
   override which Haskell package set is used by the exploration process. Note
   that this will not affect things *other* than exploration, like function
   extraction or setup code.
 - Note that we use the `nix-eval` package, but we *don't* expose its
   `NIX_EVAL_HASKELL_PKGS` override. That's because we need to use it ourselves,
   but the `HASKELL_PACKAGES` we provide acts in a similar way.

## Quick Summary ##

 - You'll need the Nix package manager and a UNIX-like OS (tested on Linux). Nix
   will take care of gathering any other dependencies.
 - The main "user facing" functionality is the package provided by `default.nix`
   which contains scripts for exploring Haskell packages:
  - `haskellPkgToAsts d` will look in directory `d` for a Haskell package (i.e.
    a `.cabal` file) and extract ASTs for every function defined in the package,
    including whether or not they're suitable for exploring.
  - `quickspecAsts d` will start GHC with the Haskell package of directory `d`
    in scope, and explore all of the suitable ASTs it's given on stdin.
  - `quickspec d` combines `haskellPkgToAsts d` and `quickspecAsts d`.
 - The main "researcher facing" functionality is the benchmark suite, which is
   explained in more detail by `benchmarks/README`.
